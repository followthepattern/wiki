---
title: File operations in Go
description: Golang provides various levels of abstraction to manage file operations
---

# File Operations in Go

Creating, reading, and writing files are common tasks in application development, especially for CLI (Command Line Interface) programs.

Golang provides various levels of abstraction to manage file operations. In this section, we focus on methods that are both user-friendly and efficient.

## Creating a File

Creating a file in Go is straightforward. The `os` package includes a function named `Create`, which is used to create a file. The file path can be either absolute or relative. The function returns a tuple: an `os.File` object, which contains metadata about the created file, and an `error`, which captures any failures that may occur.

Below is a typical example of using the `os.Create` function:

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	_, err := os.Create("./dump.txt") // Create a new file
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1) // Exit the application while printing the error
	}
}
```

Run the code [here](https://goplay.followthepattern.net/snippet/PVrTq5Gshin).

## Reading from a File

The simplest way to read the contents of a file into a variable is by using the `os.ReadFile` function. This function reads the entire file content into a string variable and also returns an `error` to capture the reason for any failures.

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	entireFile, err := os.ReadFile("file.txt") // Assuming 'file.txt' is the intended file path
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1)
	}
	fmt.Println(entireFile)
}
```

## Reading File Content into a Binary Array

The following example demonstrates a lower-level implementation of file reading. The `Read` function fills a byte array with data from the file, allowing you to specify the length of the array.

```go
package main

import (
	"fmt"
	"os"
)

func main() {
	file, err := os.Open("./dump.txt") // Open file
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1) // Exit if file can't be opened
	}

	data := make([]byte, 50)
	count, err := file.Read(data) // Read from the file
	if err != nil {
		fmt.Println(err.Error())
		os.Exit(1) // Exit if reading fails
	}

	text := data[:count]
	fmt.Printf("count: %d characters: %q string: %s", count, text, text) // Print the file content
}
```

In this example, the application opens a file named `dump.txt` and reads its content into a byte slice named `data`. Note that the length and capacity of the slice are limited to 50, meaning it will read only the first 50 characters into the `data` byte array.

## Checking if a File Exists

This approach is arguably the most readable way to check if a file exists in Go. While there are other methods to verify the existence of a file, this one stands out for its clarity.

```go copy {11}
package main

import (
	"fmt"
	"os"
)

func main() {
	filename := "file.txt"

	if _, err := os.Stat(filename); os.IsNotExist(err) {
		fmt.Printf("File %s does not exist.\n", filename)
	} else {
		fmt.Printf("File %s exists.\n", filename)
	}
}
```

In this example, `os.Stat` is used to retrieve the file's status. If the file does not exist, `os.Stat` returns an error that satisfies `os.IsNotExist`, indicating the absence of the file.